<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YuGao&#39;s Blog</title>
  
  
  <link href="/rss.xml" rel="self"/>
  
  <link href="https://sxyugao.top/"/>
  <updated>2019-05-11T14:50:41.658Z</updated>
  <id>https://sxyugao.top/</id>
  
  <author>
    <name>sxyugao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Arch Linux 的安装与配置</title>
    <link href="https://sxyugao.top/p/22002c08.html"/>
    <id>https://sxyugao.top/p/22002c08.html</id>
    <published>2019-05-11T14:02:52.000Z</published>
    <updated>2019-05-11T14:50:41.658Z</updated>
    
    <content type="html"><![CDATA[<p>最近折腾了一下 Arch Linux，写一篇安装教程纪念一下。</p><p><strong>环境为 HP Notebook x86_64，UEFI</strong>。</p><a id="more"></a><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><h4 id="安装介质"><a href="#安装介质" class="headerlink" title="安装介质"></a>安装介质</h4><ol><li><p>前往<a href="https://www.archlinux.org/download/" target="_blank" rel="noopener">下载</a>页面，在 China 栏下载镜像</p></li><li><p>如果你是 Linux 用户推荐使用<code>dd</code>命令写入镜像，Windows 用户可以尝试开源小工具 <a href="https://rufus.ie/" target="_blank" rel="noopener">rufus</a>来制作安装介质。</p></li></ol><h4 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h4><p>保证有一个足够大的空闲分区（或新磁盘）。</p><h3 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a>正式安装</h3><h4 id="启动介质"><a href="#启动介质" class="headerlink" title="启动介质"></a>启动介质</h4><p>自行设置启动顺序，相信都能解决的。注意，UEFI 启用安全模式启动可能会导致跳过已经写好的介质，如遇到这个问题请设置为传统模式启动。</p><p>然后就进入了 U 盘里的 Arch Linux 了。</p><h4 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h4><p>Arch Linux 的安装离不开网络。</p><p>如果你使用无线网络，使用以下命令来联网：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wifi-menu</span><br></pre></td></tr></table></figure><p>如果是有线网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dhcpcd</span><br></pre></td></tr></table></figure><p>然后使用以下命令检查是否设置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure><h4 id="选择镜像源"><a href="#选择镜像源" class="headerlink" title="选择镜像源"></a>选择镜像源</h4><p>默认读者已经了解 Vim 基本操作。</p><p>这里我们选择使用速度最快的清华源（当然你也可以选择其他的）。</p><p>通过 Vim 打开 <code>/etc/pacman.d/mirrorlist</code>，在列表最上方写入 <code>https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</code>，保存并退出。</p><h4 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h4><p>暂时默认已经存在引导分区。</p><p>先使用 <code>fdisk -l</code> 查看当前分区情况。</p><p>然后将你需要的安装的分区格式化为 ext4 格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sdxY （请将的sdxY替换为需要的分区）</span><br></pre></td></tr></table></figure><h4 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h4><p>执行以下命令挂载根分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdaxY /mnt （请将sdxY替换为之前的根分区）</span><br></pre></td></tr></table></figure><p>挂载引导分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/boot</span><br><span class="line">mount /dev/sdxY /mnt/boot （请将sdxY替换为之前的引导分区）</span><br></pre></td></tr></table></figure><p><strong>未完持续…</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近折腾了一下 Arch Linux，写一篇安装教程纪念一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境为 HP Notebook x86_64，UEFI&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="极客" scheme="https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"/>
    
    
      <category term="Linux" scheme="https://sxyugao.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>网络流24题</title>
    <link href="https://sxyugao.top/p/7a448387.html"/>
    <id>https://sxyugao.top/p/7a448387.html</id>
    <published>2019-03-14T03:39:49.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近发现网络流只会板子不会模型转换，于是来做网络流 24 题。</p><p>本文代码以 LibreOJ 上的数据为准，Luogu 的题面可能稍有不同。</p><p>本文不定时更新。 <del>（有可能永久咕咕咕）</del></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近发现网络流只会板子不会模型转换，于是来做网络流 24 题。&lt;/p&gt;
&lt;p&gt;本文代码以 LibreOJ 上的数据为准，Luogu 的题面可
      
    
    </summary>
    
      <category term="题解" scheme="https://sxyugao.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="网络流" scheme="https://sxyugao.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>美化你的PowerShell</title>
    <link href="https://sxyugao.top/p/aa39dfc6.html"/>
    <id>https://sxyugao.top/p/aa39dfc6.html</id>
    <published>2019-03-03T02:58:52.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为 Windows 用户，常羡慕 Linux 用户高端大气的终端。</p><p>其实，Windows 自带的 PowerShell 也十分的强大。</p><p>但是过于简陋的界面不知道劝退了多少用户，于是让我们来美化一下 PowerShell 吧。</p><p>以下教程环境均为 PowerShell 5.x。</p><a id="more"></a><h3 id="准备-PowerShell-5-x"><a href="#准备-PowerShell-5-x" class="headerlink" title="准备 PowerShell 5.x"></a>准备 PowerShell 5.x</h3><blockquote><p>Windows10 用户请直接跳过这个步骤，因为 Windows10 内置了 PowerShell 5.x。</p></blockquote><p>我们去<a href="https://www.microsoft.com/en-us/download/details.aspx?id=54616" target="_blank" rel="noopener">官网</a>下载 Windows Management Framework 5.1，选择对应的版本下载。</p><p>注意，请关注对应的系统前缀，别下载错了。</p><p>下载好以后如果是压缩包运行里面的<code>.msu</code>文件，不要使用<code>.ps1</code>来安装。</p><p>安装好以后重启即可。</p><h3 id="安装-posh-git"><a href="#安装-posh-git" class="headerlink" title="安装 posh-git"></a>安装 posh-git</h3><p>折腾 PowerShell 的人大多有 Git 的需求，但是 PowerShell 默认不支持 Git，没有仓库显示和 tab 补全。这时候我们就需要额外的模块来提供这个功能。</p><p>执行以下命令安装 posh-git：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Module posh-git -Scope CurrentUser</span><br></pre></td></tr></table></figure><p>它会提示你先安装 NuGet，直接选择“是”。</p><p>安装过程中可能会有这样的警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不受信任的存储库</span><br><span class="line">你正在从不受信任的存储库安装模块。如果你信任该存储库，请通过运行 Set-PSRepository</span><br><span class="line">cmdlet 更改其 InstallationPolicy 值。是否确实要从“PSGallery”安装模块?</span><br><span class="line">[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助</span><br></pre></td></tr></table></figure><p>直接选“是”，如果你觉得这个警告烦人，直接执行以下代码信任该仓库即可：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-PSRepository -Name PSGallery -InstallationPolicy Trusted</span><br></pre></td></tr></table></figure><p>执行以下命令引入 posh-git：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> posh-git</span><br></pre></td></tr></table></figure><p>可能会有以下的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/</span><br><span class="line">?LinkID=135170 中的 about_Execution_Policies。</span><br></pre></td></tr></table></figure><p>不要紧，更改一下执行权限：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> -Scope CurrentUser Bypass</span><br></pre></td></tr></table></figure><p>再引入 posh-git，然后就能体验到 git 的 tab 补全了。</p><h3 id="安装-DirColors"><a href="#安装-DirColors" class="headerlink" title="安装 DirColors"></a>安装 DirColors</h3><blockquote><p>注意，此模块笔者在 Windows7 环境下体验不佳，不推荐非 Windows10 用户使用。</p></blockquote><p>Linux 下的 ls 命令支持对不同文件进行高亮，PowerShell 肯定不能少了这个功能。</p><p>我们执行以下命令安装并引入 DirColors：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Install-Module DirColors -Scope CurrentUser</span><br><span class="line"><span class="built_in">Import-Module</span> DirColors</span><br></pre></td></tr></table></figure><p>你还能自定义高亮格式，使用以下代码来引入配置文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Update-DirColors 配置文件的路径</span><br></pre></td></tr></table></figure><h3 id="安装-oh-my-posh"><a href="#安装-oh-my-posh" class="headerlink" title="安装 oh-my-posh"></a>安装 oh-my-posh</h3><p>用过 Linux 的人基本都用过神器 oh-my-zsh，而 PowerShell 也有类似的模块 oh-my-posh。oh-my-posh 提供了一个和 oh-my-zsh 类似的界面，颜值满分。</p><p>执行以下命令安装并引入 oh-my-posh：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Install-Module oh-my-posh -Scope CurrentUser</span><br><span class="line"><span class="built_in">Import-Module</span> oh-my-posh</span><br></pre></td></tr></table></figure><blockquote><p>oh-my-posh 的 git 功能依赖 posh-git，请务必先安装 posh-git</p></blockquote><p>使用以下命令来切换 oh-my-posh 的主题：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Theme robbyrussell</span><br><span class="line"><span class="comment"># 这个是 oh-my-zsh 的默认主题</span></span><br><span class="line"><span class="comment"># 更多主题参见 https://github.com/JanDeDobbeleer/oh-my-posh#Themes</span></span><br></pre></td></tr></table></figure><p>一个漂亮的界面就出现在你面前了。</p><h3 id="使用-Cmder"><a href="#使用-Cmder" class="headerlink" title="使用 Cmder"></a>使用 Cmder</h3><p>笔者在 Windows7 下使用 oh-my-posh 出现了显示问题，怀疑是因为自带的界面过于陈旧，使用 Cmder 就解决了。</p><p>去<a href="https://cmder.net/" target="_blank" rel="noopener">官网</a>下载 Cmder，哪个版本都无所谓。</p><p>在解压目录下运行<code>Cmder.exe /REGISTER ALL</code>注册右键菜单，就能在任何目录下使用 Cmder 了。</p><p>设置默认启动为 PowerShell，Cmder 的设置就请读者自行搜索，笔者在此不再赘述。</p><h3 id="安装-PSReadLine"><a href="#安装-PSReadLine" class="headerlink" title="安装 PSReadLine"></a>安装 PSReadLine</h3><p>有了漂亮的 shell，为什么不来语法高亮呢？</p><p>PSReadLine 正是为 PowerShell 提供命令行高亮的模块。</p><p>使用以下命令安装并引入 PSReadLine：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Install-Module PSReadLine -Scope CurrentUser</span><br><span class="line"><span class="built_in">Import-Module</span> PSReadLine</span><br></pre></td></tr></table></figure><p>试着打几句命令，感受一下代码高亮吧。</p><h3 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h3><p>可能你在上一步尝试使用其他主题的时候就发现有一些奇怪的字符无法显示，这是因为系统缺失相应的字体。</p><p>执行以下代码来安装 Powerline 字体：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/powerline/fonts.git</span><br><span class="line">cd .\fonts\</span><br><span class="line">.\install.ps1</span><br></pre></td></tr></table></figure><p>安装好后执行以下代码删除多余文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line"><span class="built_in">Remove-Item</span> -Force .\fonts\</span><br></pre></td></tr></table></figure><p>打开你的 PowerShell 界面，在标题栏右键选中“默认值”，在“字体”选项中使用著名的“逮虾户”字体 (DejaVu Sans Mono for Powerline)。</p><p>当然你也可以根据自己的喜好来安装自己喜欢的字体，比如更纱黑体 (Sarasa Term SC)。更纱黑体内置了 Powerline 字体，字形很纤细，看上去也很舒服。</p><h3 id="窗口透明度和配色"><a href="#窗口透明度和配色" class="headerlink" title="窗口透明度和配色"></a>窗口透明度和配色</h3><blockquote><p>这个设置是针对默认命令行窗口的，和前文介绍的 Cmder 无关。<br>笔者在 Windows7 环境下体验不佳，不推荐非 Windows10 用户使用。</p></blockquote><p>Linux 下的终端有着炫酷的配色，全局呼出终端时半透明的窗口也显得逼格满满。</p><p>其实，Windows 的终端也能那么炫酷。</p><p>打开 PowerShell，在标题栏右键选中“默认值”，在“颜色”选项中设置“不透明度”，透明窗口就设置成功了。</p><p>配色方案的话，我们下载微软官方的工具<a href="https://github.com/Microsoft/console/releases" target="_blank" rel="noopener">ColorTool</a>来配置。</p><p>在解压后在目录下打开 PowerShell，执行<code>.\colortool -b campbell</code>，即可把终端配色改为<code>campbell</code>。但是如果 ColorTool 自带的配色方案不喜欢怎么办？不要紧，这个小工具支持 itermcolor 格式，我们可以在<a href="https://github.com/mbadolato/iTerm2-Color-Schemes" target="_blank" rel="noopener">iTerm2 Color Schemes</a>挑选喜欢的配色主题，下载以后放置在 ColorTool 的 schemes 文件夹下，执行<code>.\colortool -b 主题名</code>即可。</p><h3 id="配置-PROFILE"><a href="#配置-PROFILE" class="headerlink" title="配置 PROFILE"></a>配置 PROFILE</h3><p>我们的美化基本完成了，让我们理一理现在我们启动 PowerShell 后的操作：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> DirColors</span><br><span class="line">Update-DirColors 配置文件的路径 <span class="comment"># 若没有可以忽略该行</span></span><br><span class="line"><span class="built_in">Import-Module</span> oh-my-posh</span><br><span class="line"><span class="comment"># 由于 oh-my-posh 会自动引入 posh-git，所以我们不必再次引入</span></span><br><span class="line">Set-Theme 你自己喜欢的主题</span><br><span class="line"><span class="built_in">Import-Module</span> PSReadLine</span><br></pre></td></tr></table></figure><p>每次都这么打一遍是不是很繁琐？还好 PowerShell 为我们提供了 PROFILE。</p><p>在 PowerShell 里键入以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$PROFILE</span></span><br></pre></td></tr></table></figure><p>发现输出了一个文件的目录，直接用文本编辑器打开它，输入刚才引入模块的命令，保存并退出。</p><p>现在你每次打开 PowerShell 就会先引入 PROFILE 里的命令，节约了大量时间。</p><p>如果你自己有其他的需求，自行添加即可。</p><h3 id="Screenfetch"><a href="#Screenfetch" class="headerlink" title="Screenfetch"></a>Screenfetch</h3><p>Linux 装机以后必晒图之一就是 screenfetch 了，想不到在 Windows 下也有这种东西。</p><p>执行以下命令安装 screenfetch：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Module windows-screenfetch -Scope CurrentUser</span><br></pre></td></tr></table></figure><p>令人震惊的是这个模块居然不需要 Import。。</p><p>安装好以后直接输入 Screenfetch 就可以看到效果了，十分炫酷。</p><p>这是我的辣鸡电脑，分辨率不高，将就看以下吧。。</p><p><img src="https://i.loli.net/2019/03/03/5c7bb0c791797.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;作为 Windows 用户，常羡慕 Linux 用户高端大气的终端。&lt;/p&gt;
&lt;p&gt;其实，Windows 自带的 PowerShell 也十分的强大。&lt;/p&gt;
&lt;p&gt;但是过于简陋的界面不知道劝退了多少用户，于是让我们来美化一下 PowerShell 吧。&lt;/p&gt;
&lt;p&gt;以下教程环境均为 PowerShell 5.x。&lt;/p&gt;
    
    </summary>
    
      <category term="极客" scheme="https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"/>
    
    
      <category term="PowerShell" scheme="https://sxyugao.top/tags/PowerShell/"/>
    
      <category term="软件" scheme="https://sxyugao.top/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P3613 - 睡觉困难综合征</title>
    <link href="https://sxyugao.top/p/6e0912cc.html"/>
    <id>https://sxyugao.top/p/6e0912cc.html</id>
    <published>2019-02-27T23:46:19.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们要知道这道题的原型是「NOI2014」起床困难综合症。</p><blockquote><p>总是有出题人喜欢把序列上用线段树解决的题目出到树上，让选手强行写个树链剖分或树分治或某种动态树数据结构。</p></blockquote><p>序列问题转化为树上问题，很容易想到树链剖分，直接上板子。</p><a id="more"></a><p>统计答案时因为二进制的特殊性质，后面每一位都选 1 都不大于这一位选 1，所以直接贪心即可。</p><p>注意到题面里询问的 x，y 是有方向性的，我们还要维护反向的状态。</p><p>但是如果每一位单独维护的话，时间复杂度爆炸，考虑把这些信息压进一个 unsigned long long 里。</p><p>这样的话怎么维护信息呢？我们定义一个结构体表示这段进来为 0/1 时出来的情况，不难发现如果这一位出来是 1 只有这么几种情况：左儿子进来是 0，出来是 0，右儿子进来是 0，出来是 1；左儿子进来是 1，出来是 0，右儿子进来是 0，出来是 1；左儿子进来是 0，出来是 1，右儿子进来是 1，出来是 1；左儿子进来是 1，出来是 1，右儿子进来是 1，出来是 1。</p><p>用 C++表示就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ans.x0 = (x0 &amp; b.x1) | ((~x0) &amp; b.x0);</span><br><span class="line">ans.x1 = (x1 &amp; b.x1) | ((~x1) &amp; b.x0);</span><br></pre></td></tr></table></figure><p><del>可见自然语言的繁琐</del></p><p>代码中用到了一个小技巧——重载运算符，这个能使代码更加简洁易懂，提升代码复用性。</p><p>以下就是冗长的代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc c = getchar()</span></span><br><span class="line"><span class="function">ull <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ull x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> gc;</span><br><span class="line">  <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); gc)</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); gc) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> nedge, head[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; edge[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  edge[++nedge].to = y;</span><br><span class="line">  edge[nedge].nxt = head[x];</span><br><span class="line">  head[x] = nedge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N], son[N], siz[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  fa[x] = f;</span><br><span class="line">  siz[x] = <span class="number">1</span>;</span><br><span class="line">  dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = edge[i].to;</span><br><span class="line">    <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">    dfs1(y, x);</span><br><span class="line">    siz[x] += siz[y];</span><br><span class="line">    <span class="keyword">if</span> (siz[y] &gt; mx) &#123;</span><br><span class="line">      mx = siz[y];</span><br><span class="line">      son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot, id[N], p[N], top[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">  top[x] = topf;</span><br><span class="line">  id[x] = ++tot;</span><br><span class="line">  p[tot] = x;</span><br><span class="line">  <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">  dfs2(son[x], topf);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = edge[i].to;</span><br><span class="line">    <span class="keyword">if</span> (y == fa[x] || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">    dfs2(y, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">  ull x0, x1;</span><br><span class="line">  Data() &#123; x0 = <span class="number">0</span>, x1 = ~<span class="number">0</span>; &#125;</span><br><span class="line">  Data(<span class="keyword">int</span> opt, ull x) &#123;</span><br><span class="line">    x0 = <span class="number">0</span>, x1 = ~<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      x0 &amp;= x;</span><br><span class="line">      x1 &amp;= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">      x0 |= x;</span><br><span class="line">      x1 |= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">3</span>) &#123;</span><br><span class="line">      x0 ^= x;</span><br><span class="line">      x1 ^= x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Data <span class="keyword">operator</span>+(<span class="keyword">const</span> Data &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    Data ans;</span><br><span class="line">    ans.x0 = (x0 &amp; b.x1) | ((~x0) &amp; b.x0);</span><br><span class="line">    ans.x1 = (x1 &amp; b.x1) | ((~x1) &amp; b.x0);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ull <span class="title">query</span><span class="params">(ull x)</span> </span>&#123;</span><br><span class="line">    ull ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; ~i; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x0 &amp; (<span class="number">1u</span>ll &lt;&lt; i)) &#123;</span><br><span class="line">        ans += (<span class="number">1u</span>ll &lt;&lt; i);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x1 &amp; (<span class="number">1u</span>ll &lt;&lt; i) &amp;&amp; (<span class="number">1u</span>ll &lt;&lt; i) &lt;= x) &#123;</span><br><span class="line">        x -= (<span class="number">1u</span>ll &lt;&lt; i);</span><br><span class="line">        ans += (<span class="number">1u</span>ll &lt;&lt; i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Data a[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (k &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span> &#123;</span></span><br><span class="line">  Data lv[N &lt;&lt; <span class="number">2</span>], rv[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    lv[k] = lv[ls] + lv[rs];</span><br><span class="line">    rv[k] = rv[rs] + rv[ls];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      lv[k] = rv[k] = a[p[l]];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(ls, l, mid);</span><br><span class="line">    build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    pushup(k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, Data x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(lv[k] = rv[k] = x);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) &#123;</span><br><span class="line">      modify(ls, l, mid, p, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      modify(rs, mid + <span class="number">1</span>, r, p, x);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Data <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">bool</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> opt ? rv[k] : lv[k];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (qr &lt;= mid) <span class="keyword">return</span> query(ls, l, mid, ql, qr, opt);</span><br><span class="line">    <span class="keyword">if</span> (ql &gt; mid) <span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, ql, qr, opt);</span><br><span class="line">    Data L = query(ls, l, mid, ql, qr, opt);</span><br><span class="line">    Data R = query(rs, mid + <span class="number">1</span>, r, ql, qr, opt);</span><br><span class="line">    <span class="keyword">if</span> (opt) <span class="keyword">return</span> R + L;</span><br><span class="line">    <span class="keyword">return</span> L + R;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rs</span></span><br><span class="line"><span class="function">Data <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  Data L, R;</span><br><span class="line">  <span class="keyword">while</span> (top[x] ^ top[y]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]]) &#123;</span><br><span class="line">      L = L + seg.query(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x], <span class="number">1</span>);</span><br><span class="line">      x = fa[top[x]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      R = seg.query(<span class="number">1</span>, <span class="number">1</span>, n, id[top[y]], id[y], <span class="number">0</span>) + R;</span><br><span class="line">      y = fa[top[y]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Data tmp;</span><br><span class="line">  <span class="keyword">if</span> (dep[x] &gt; dep[y]) &#123;</span><br><span class="line">    tmp = L + seg.query(<span class="number">1</span>, <span class="number">1</span>, n, id[y], id[x], <span class="number">1</span>);</span><br><span class="line">    tmp = tmp + R;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dep[x] &gt; dep[y]) <span class="keyword">return</span> L + seg.query(<span class="number">1</span>, <span class="number">1</span>, n, id[y], id[x], <span class="number">1</span>) + R;</span><br><span class="line">  <span class="keyword">return</span> L + seg.query(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y], <span class="number">0</span>) + R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = read(), m = read(), k = read();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> opt = read();</span><br><span class="line">    ull x = read();</span><br><span class="line">    a[i] = Data(opt, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">    add(x, y), add(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  seg.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="keyword">int</span> opt = read(), x = read(), y = read();</span><br><span class="line">    ull z = read();</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">      seg.modify(<span class="number">1</span>, <span class="number">1</span>, n, id[x], Data(y, z));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Data ans = query(x, y);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%llu\n"</span>, ans.query(z));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们要知道这道题的原型是「NOI2014」起床困难综合症。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总是有出题人喜欢把序列上用线段树解决的题目出到树上，让选手强行写个树链剖分或树分治或某种动态树数据结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;序列问题转化为树上问题，很容易想到树链剖分，直接上板子。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://sxyugao.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="线段树" scheme="https://sxyugao.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="树链剖分" scheme="https://sxyugao.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="树上问题" scheme="https://sxyugao.top/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P4884 - 多少个1？</title>
    <link href="https://sxyugao.top/p/cbf2e03c.html"/>
    <id>https://sxyugao.top/p/cbf2e03c.html</id>
    <published>2018-09-26T23:32:03.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<p>我们通过观察可以发现 $11\cdots1$ 可以变化为 $\frac{10^{n}-1}{9}$，于是根据取模的性质，我们可以把原式两边同乘九再加一、原式变为 $10^{n} \equiv k \cdot 9 + 1 \pmod m$，发现这是个 BSGS 的标准式子，由于$m$保证为质数，所以也不必用拓展 BSGS。</p><a id="more"></a><p>然后愉快地交了一发，发现只有 80 分。再看一眼数据范围——中间过程相乘会爆$long\;long$，所以我们需要快速乘来防止溢出。然而丧心病狂的出题人卡 $log_{n}$的快速乘，所以我们需要复杂度更优常数更小的快速乘：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传说中复杂度更优的O(1)快速乘</span></span><br><span class="line"><span class="comment">// 参考链接：https://zhuanlan.zhihu.com/p/31872064</span></span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a, LL b, LL P)</span> </span>&#123;</span><br><span class="line">    LL L = a * (b &gt;&gt; <span class="number">25L</span>L) % P * (<span class="number">1L</span>L &lt;&lt; <span class="number">25</span>) % P;</span><br><span class="line">    LL R = a * (b &amp; ((<span class="number">1L</span>L &lt;&lt; <span class="number">25</span>) - <span class="number">1</span>)) % P;</span><br><span class="line">    <span class="keyword">return</span> (L + R) % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看着这么高级其实就是利用了小学生都会的乘法分配律。</p><p>我们要计算 $a \cdot b\;mod\;p$，设 $b=L+R$。</p><p>那么原式就变为 $a\cdot(L+R)\;mod\;p=((a\cdot L)\;mod\;p+(a\cdot R)\;mod\;p)\;mod\;p$。</p><p>我们把 $L$ 钦定为 $b$ 的二进制前 $x$ 位，$R$ 为 $b$ 的后 $(64-x)$ 位。</p><p>就得到了以上的代码（以上这份代码 $x=25$）。</p><p>用上这样的快速乘就可以 AC 了。</p><p>以下为代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL k, m;</span><br><span class="line"><span class="comment">// C++11标准及以上的哈希表unordered_map</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;LL, LL&gt; Hash;</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a, LL b, LL P)</span> </span>&#123;</span><br><span class="line">  LL L = a * (b &gt;&gt; <span class="number">25L</span>L) % P * (<span class="number">1L</span>L &lt;&lt; <span class="number">25</span>) % P;</span><br><span class="line">  LL R = a * (b &amp; ((<span class="number">1L</span>L &lt;&lt; <span class="number">25</span>) - <span class="number">1</span>)) % P;</span><br><span class="line">  <span class="keyword">return</span> (L + R) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pw</span><span class="params">(LL a, LL n, LL P)</span> </span>&#123;</span><br><span class="line">  LL ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans = mul(ans, a, P);</span><br><span class="line">    a = mul(a, a, P);</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">BSGS</span><span class="params">(LL a, LL b, LL P)</span> </span>&#123;</span><br><span class="line">  LL len = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(P));</span><br><span class="line">  <span class="keyword">for</span> (LL i = <span class="number">0</span>; i &lt; len; i++) Hash[mul(b, pw(a, i, P), P)] = i;</span><br><span class="line">  a = pw(a, len, P);</span><br><span class="line">  <span class="keyword">for</span> (LL i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    LL x = pw(a, i, P);</span><br><span class="line">    LL j = Hash.count(x) ? Hash[x] : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; i * len - j &gt;= <span class="number">0</span>) <span class="keyword">return</span> i * len - j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;k, &amp;m);</span><br><span class="line">  k = k * <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">  k %= m;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld"</span>, BSGS(<span class="number">10</span>, k, m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们通过观察可以发现 $11\cdots1$ 可以变化为 $\frac{10^{n}-1}{9}$，于是根据取模的性质，我们可以把原式两边同乘九再加一、原式变为 $10^{n} \equiv k \cdot 9 + 1 \pmod m$，发现这是个 BSGS 的标准式子，由于$m$保证为质数，所以也不必用拓展 BSGS。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://sxyugao.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数论" scheme="https://sxyugao.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CF1037D - Valid BFS?</title>
    <link href="https://sxyugao.top/p/3396b077.html"/>
    <id>https://sxyugao.top/p/3396b077.html</id>
    <published>2018-09-20T01:56:22.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<p>作为一道英文题，我们先解释一下题意：</p><p>给你一棵树和它的一个 BFS 序，让你判断这个 BFS 序是否是一个从节点 1 开始的合法 BFS 序。</p><p>接下来我们进入正题。</p><p>第一眼看到这题时，大部分人都会想到，既然是树，那么它一定是一层一层地向下 BFS。</p><p>也就是说，BFS 序中越后出现的节点，它树上的深度肯定是大于它前面的节点的。</p><p>于是照这个思想打完后，发现 Wrong Answer 了。</p><a id="more"></a><p>显然这个思路是有反例的，比如下图的情况：</p><p><img src="https://i.loli.net/2019/01/29/5c5061bbb4545.png" alt></p><p>输入给的 BFS 序为：1 5 2 3 4 6</p><p>如果根据原来的思路输出就是 Yes，然而正确的 BFS 序显然是 1 5 2 6 3 4</p><p>再仔细思考一下，发现合法的 BFS 序不仅要满足刚才的深度条件，而且满足每个节点的父亲在 BFS 序中的位置都要不晚于在它后面出现的节点父亲的位置。</p><p>这么看貌似时间复杂度是$O(N^2)$的，如何减小复杂度呢？</p><p>我们发现一个节点的子树是一个连续的区间，我们直接把每个节点重新编号为它父节点的编号，再把连续相同编号的节点的合并成一个节点即可。合并好以后有一个很好的性质，若输入的序列为合法的 BFS 序，重新编号后的序列元素在原序列中的位置单调递增。这样，时间复杂度就降到了$O(n)$了。</p><p>以下为代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc c = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line">    <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); gc) <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); gc) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> nedge, head[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; edge[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++nedge].to = y;</span><br><span class="line">    edge[nedge].nxt = head[x];</span><br><span class="line">    head[x] = nedge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d[MAXN], f[MAXN], a[MAXN], b[MAXN], id[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    d[k] = d[fa] + <span class="number">1</span>;</span><br><span class="line">    f[k] = fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[k]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(u == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(u, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        add(x, y); add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(d[a[i]] &lt; d[a[i - <span class="number">1</span>]]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以上为深度条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) id[a[i]] = i;</span><br><span class="line">    <span class="comment">// 原序列中的位置直接开桶记录</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = f[a[i]];</span><br><span class="line">    <span class="comment">// b为重新编号后的序列</span></span><br><span class="line">    <span class="keyword">int</span> len = unique(b + <span class="number">1</span>, b + n + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        <span class="keyword">if</span>(id[b[i]] &lt; id[b[i - <span class="number">1</span>]]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以上为父节点条件</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一道英文题，我们先解释一下题意：&lt;/p&gt;
&lt;p&gt;给你一棵树和它的一个 BFS 序，让你判断这个 BFS 序是否是一个从节点 1 开始的合法 BFS 序。&lt;/p&gt;
&lt;p&gt;接下来我们进入正题。&lt;/p&gt;
&lt;p&gt;第一眼看到这题时，大部分人都会想到，既然是树，那么它一定是一层一层地向下 BFS。&lt;/p&gt;
&lt;p&gt;也就是说，BFS 序中越后出现的节点，它树上的深度肯定是大于它前面的节点的。&lt;/p&gt;
&lt;p&gt;于是照这个思想打完后，发现 Wrong Answer 了。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://sxyugao.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="BFS" scheme="https://sxyugao.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2094 - 运输</title>
    <link href="https://sxyugao.top/p/69c58062.html"/>
    <id>https://sxyugao.top/p/69c58062.html</id>
    <published>2018-09-20T01:43:27.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<p>这道题第一眼像是合并果子，我们考虑贪心。</p><p>我们先选择一种贪心策略：每次选当前最大的两个数合并，直到只剩最后一件物品。</p><p>接下来我们证明一下为什么这样是对的：</p><p>我们先想一想合并果子，那道题的贪心策略与这道题相反，每次选最小的两个数合并。考虑它为什么是对的——我们发现越先选的数对结果的贡献越大，为了使结果尽可能小，肯定是越小的先选越好。</p><a id="more"></a><p>有了这题做基础，我们来考虑这道题。我们发现越先选的数被$k$除的次数也就越多，为了使结果尽可能小，肯定是让越大的数除$k$的次数越多越好，自此，贪心策略证明完毕。</p><p>以下为代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc c = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line">    <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); gc) <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); gc) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read(), k = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) q.push(read());</span><br><span class="line">    <span class="keyword">while</span>(q.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line">        <span class="keyword">int</span> y = q.top(); q.pop();</span><br><span class="line">        q.push((x + y) / k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, q.top());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题第一眼像是合并果子，我们考虑贪心。&lt;/p&gt;
&lt;p&gt;我们先选择一种贪心策略：每次选当前最大的两个数合并，直到只剩最后一件物品。&lt;/p&gt;
&lt;p&gt;接下来我们证明一下为什么这样是对的：&lt;/p&gt;
&lt;p&gt;我们先想一想合并果子，那道题的贪心策略与这道题相反，每次选最小的两个数合并。考虑它为什么是对的——我们发现越先选的数对结果的贡献越大，为了使结果尽可能小，肯定是越小的先选越好。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://sxyugao.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="STL" scheme="https://sxyugao.top/tags/STL/"/>
    
      <category term="贪心" scheme="https://sxyugao.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2988 - Test Taking</title>
    <link href="https://sxyugao.top/p/1192747.html"/>
    <id>https://sxyugao.top/p/1192747.html</id>
    <published>2018-06-21T17:10:00.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<p>作为一道英文题，我们先解释一下题意：</p><p>给你一个长度为 $n$ 的 01 串，其中可能至少有 $t_{i}$ 个 1，问最后你给出一个 01 串可能和其匹配的最大长度。</p><p>接下来我们进入正题。</p><p>第一眼看见觉得是水题，对于每个$t_{i}$枚举应该全 0 还是全 1，但是这显然可以找出反例来。</p><a id="more"></a><p>那么我们应该怎么贪心呢？</p><p>首先，我们先提出一个引理：</p><p>对于两个长度为 $n$ 的 01 串，$A$ 中 $a$ 个 1，$B$ 中 $b$ 个 1，任一排列中相同位置元素相同的数量至少为 $max(a+b-n,n-a-b)$。</p><p>接下来我们证明一下。</p><p>1、$a+b&gt;n$，即 $A$ 和 $B$ 匹配 1。</p><p>我们为了让相同元素尽可能少，考虑把 $A$ 中的 1 全移到前端，$B$ 中的 1 全移到后端，变成线段覆盖问题，重合部分为 $a+b-n$。</p><p>2、$a+b&lt;n$，即 $A$ 和 $B$ 匹配 0.</p><p>同理，我们考虑把 $A$ 中的 0 全移到前端，$B$ 中的 0 全移到后端，用同样的方法得出该情况下结果为 $n-a-b$。</p><p>3、$a+b=n$，显然答案为 0。</p><p>说完了引理，我们再接着讲题。</p><p>我们先将 $t$ 从小到大排序，设当前要匹配的 01 串为 $S$，其中有 $x$ 个 1。</p><p>对于每对 $t_{i-1},t_{i}$，我们肯定是拿 $S$ 和 $t_{i-1}$ 去匹配 0，和 $t_{i}$ 去匹配 1。</p><p>由引理得 $Ans=max(n-t_{i-1}-x,t_{i}+x-n)$。</p><p>当 $n-t_{i-1}-x \geq t_{i}+x-n$ 时，</p><p>得 $Ans \geq (t_{i}-t_{i-1})/2$</p><p>同理当 $n-t_{i-1}-x \geq t_{i}+x-n$ 时，</p><p>得 $Ans \geq (t_{i}-t_{i-1})/2$</p><p>综上所述，必有 $Ans \geq (t_{i}-t_{i-1})/2$。</p><p>然后特判一下 $t_{1}$ 和 $t_{m}$，全选 0 或全选 1 的情况。</p><p>于是我们就可以愉快地切题了。</p><p>以下为代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc c=getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> gc;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); gc)<span class="keyword">if</span> (c == <span class="string">'-'</span>)f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); gc)x = x * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)a[i] = read();</span><br><span class="line">    sort(a + <span class="number">1</span>, a + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = max(a[<span class="number">1</span>], n - a[m]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)ans = max(ans, (a[i + <span class="number">1</span>] - a[i]) / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一道英文题，我们先解释一下题意：&lt;/p&gt;
&lt;p&gt;给你一个长度为 $n$ 的 01 串，其中可能至少有 $t_{i}$ 个 1，问最后你给出一个 01 串可能和其匹配的最大长度。&lt;/p&gt;
&lt;p&gt;接下来我们进入正题。&lt;/p&gt;
&lt;p&gt;第一眼看见觉得是水题，对于每个$t_{i}$枚举应该全 0 还是全 1，但是这显然可以找出反例来。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://sxyugao.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="https://sxyugao.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="排序" scheme="https://sxyugao.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1351 - 联合权值</title>
    <link href="https://sxyugao.top/p/b30e912f.html"/>
    <id>https://sxyugao.top/p/b30e912f.html</id>
    <published>2018-06-18T18:05:00.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<p>由题意得一个点对的联合权值是它们的点权相乘，而 2 个点形成点对的条件是距离为 2。</p><p>于是我们可以通过枚举这 2 个节点的公共点来算出以这个点为中心的权值和。</p><p>但是先枚举中心点再枚举其相邻的节点时间复杂度达到了$O(n^3)$，我们不能承受。</p><p>经过观察发现，对于特定的点，它都要乘上除自己以外的所有点权，再相加。然后我们就可以先处理出点权和，统计答案的时候把自己减去即可。</p><a id="more"></a><p>虽然说题面里说是有序点对，但我们每次枚举的时候都定方向为当前点-&gt;其他点，所以最后也不需要再乘 2 了。</p><p>枚举每个点，再枚举相邻的每条边，复杂度看似是$O(n^2)$，但由于树的度数为$n-1$，实际复杂度应为$O(n+m)$</p><p>当然，这道题还有一个小小的坑点，题面里只说联合权值之和要取余，最大值却不需要取余，这个细节注意一下。</p><p>接下来上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc c = getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> gc;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); gc)</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); gc) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">10007</span>;</span><br><span class="line"><span class="keyword">int</span> n, Ans, ans, a[MAXN];</span><br><span class="line"><span class="keyword">int</span> nedge, head[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; edge[MAXN * <span class="number">2</span>];  <span class="comment">// 边表2倍勿忘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    edge[++nedge].to = y;</span><br><span class="line">    edge[nedge].nxt = head[x];</span><br><span class="line">    head[x] = nedge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;  <span class="comment">// 关键函数</span></span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>, Maxx = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Max为与k相连最大的点权值，Maxx为次大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[k]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (a[u] &gt; Max) &#123;</span><br><span class="line">            Maxx = Max;</span><br><span class="line">            Max = a[u];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[u] &gt; Maxx)</span><br><span class="line">            Maxx = a[u];</span><br><span class="line">        <span class="comment">// 更新最大、次大值</span></span><br><span class="line">        sum = (sum + a[u]) % P;  <span class="comment">// 累加权值和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[k]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[i].to;</span><br><span class="line">        ans = (ans + (sum - a[u]) * a[u]) % P;</span><br><span class="line">        <span class="comment">// 当前点对答案的贡献为（除自己外总和）*（自己的权值）</span></span><br><span class="line">    &#125;</span><br><span class="line">    Ans = max(Ans, Max * Maxx);</span><br><span class="line">    <span class="comment">// 当前公共点所能产生的最大联合权值为（最大值）*（次大值）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;                                            <span class="comment">// 前向星建边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();  <span class="comment">// 读入点权</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) calc(i);        <span class="comment">// 枚举每个公共点计算</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, Ans, (ans + P) % P);</span><br><span class="line">    <span class="comment">// 因为我们在统计的时候是减一个数，所以可能会出现ans小于0的情况，要(ans+P)%P</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由题意得一个点对的联合权值是它们的点权相乘，而 2 个点形成点对的条件是距离为 2。&lt;/p&gt;
&lt;p&gt;于是我们可以通过枚举这 2 个节点的公共点来算出以这个点为中心的权值和。&lt;/p&gt;
&lt;p&gt;但是先枚举中心点再枚举其相邻的节点时间复杂度达到了$O(n^3)$，我们不能承受。&lt;/p&gt;
&lt;p&gt;经过观察发现，对于特定的点，它都要乘上除自己以外的所有点权，再相加。然后我们就可以先处理出点权和，统计答案的时候把自己减去即可。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://sxyugao.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="枚举" scheme="https://sxyugao.top/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="图论" scheme="https://sxyugao.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1432 - 倒水问题</title>
    <link href="https://sxyugao.top/p/a5166969.html"/>
    <id>https://sxyugao.top/p/a5166969.html</id>
    <published>2018-06-11T12:32:42.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<p>很容易看出这是宽度优先搜索，因为要求步数最少，且每个操作代价相同。</p><p>我们可以按操作类别分 6 种情况扩展，如果搜到最终状态就跳出 BFS（搜索顺序可以随意，因为 spj 已经配置好了，不像数据修改前要有特定的顺序）。</p><p>记得标记已经出现过的情况，不然会 TLE/MLE；</p><a id="more"></a><p><del>做宽搜题，队列能开多大就开多大。</del></p><p>正确开队列的方法：我们发现$C_{a}，C_{b}$最大只有$10^3$，也就是说总状态数最多只有$10^6$，所以把队列大小开成比状态数稍微多一点就行了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> va, vb, vc;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;va, &amp;vb, &amp;vc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, nxt, k, step;</span><br><span class="line">&#125; q[<span class="number">5000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = q[p].nxt;</span><br><span class="line">    <span class="keyword">if</span> (!t) <span class="keyword">return</span>;</span><br><span class="line">    print(t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[p].k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nxt</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> &amp;r, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> opt)</span> </span>&#123; <span class="comment">// 获取下一个状态</span></span><br><span class="line">    <span class="keyword">if</span> (vis[a][b]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 剪枝</span></span><br><span class="line">    r++;</span><br><span class="line">    q[r].a = a, q[r].b = b, q[r].k = opt;</span><br><span class="line">    q[r].nxt = l;</span><br><span class="line">    vis[a][b] = <span class="number">1</span>;</span><br><span class="line">    q[r].step = q[l].step + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q[r].b == vc) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[r].step);</span><br><span class="line">        print(r), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q[r].b == vc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q[<span class="number">1</span>].a = q[<span class="number">1</span>].b = q[<span class="number">1</span>].k = q[<span class="number">1</span>].nxt = q[<span class="number">1</span>].step = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始状态</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r &amp;&amp; !f) &#123;</span><br><span class="line">        l++;</span><br><span class="line">        f |= nxt(l, r, va, q[l].b, <span class="number">1</span>); <span class="comment">// 把A装满</span></span><br><span class="line">        f |= nxt(l, r, q[l].a, vb, <span class="number">2</span>); <span class="comment">// 把B装满</span></span><br><span class="line">        f |= nxt(l, r, <span class="number">0</span>, q[l].b, <span class="number">3</span>);  <span class="comment">// 把A倒空</span></span><br><span class="line">        f |= nxt(l, r, q[l].a, <span class="number">0</span>, <span class="number">4</span>);  <span class="comment">// 把B倒空</span></span><br><span class="line">        <span class="keyword">int</span> ta = q[l].a + q[l].b, tb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ta &gt; va) &#123;</span><br><span class="line">            tb = ta - va;</span><br><span class="line">            ta = va;</span><br><span class="line">        &#125; <span class="comment">// 如果超出容量了，那么处理一下</span></span><br><span class="line">        f |= nxt(l, r, ta, tb, <span class="number">5</span>);     <span class="comment">// 把B倒给A</span></span><br><span class="line">        ta = <span class="number">0</span>, tb = q[l].a + q[l].b;</span><br><span class="line">        <span class="keyword">if</span> (tb &gt; vb) &#123;</span><br><span class="line">            ta = tb - vb;</span><br><span class="line">            tb = vb;</span><br><span class="line">        &#125;</span><br><span class="line">        f |= nxt(l, r, ta, tb, <span class="number">6</span>);     <span class="comment">// 把A倒给B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很容易看出这是宽度优先搜索，因为要求步数最少，且每个操作代价相同。&lt;/p&gt;
&lt;p&gt;我们可以按操作类别分 6 种情况扩展，如果搜到最终状态就跳出 BFS（搜索顺序可以随意，因为 spj 已经配置好了，不像数据修改前要有特定的顺序）。&lt;/p&gt;
&lt;p&gt;记得标记已经出现过的情况，不然会 TLE/MLE；&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://sxyugao.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="BFS" scheme="https://sxyugao.top/tags/BFS/"/>
    
      <category term="STL" scheme="https://sxyugao.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2234 - 「HNOI2002」营业额统计</title>
    <link href="https://sxyugao.top/p/b5fb6ff8.html"/>
    <id>https://sxyugao.top/p/b5fb6ff8.html</id>
    <published>2018-06-08T02:35:00.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<p>根据题意我们发现对于每个$A_{i}$，与它绝对值最小的一定是前$i$个数排序后在它前面或后面的数。</p><p>这样的话，我们维护一个单调的序列，插入每天的营业额时计算其波动值即可。</p><p>最暴力的便是插入排序，复杂度$(N^2)$，不能忍受。。</p><p>我们应选择复杂度为$(NlogN)$的方法。</p><p>维护一个单调序列自然想到了 set(平衡树也可以，但是作者懒，想用 STL 水过去，逃……)，因为可能有多个相同的营业额，所以我选择了 multiset。</p><a id="more"></a><p>下次有空写一个 set 的教程。</p><p>以下为代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="comment">// 定义iter类型，免去每次打一大串的苦恼</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,ans;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s.insert(inf);s.insert(-inf);</span><br><span class="line">    <span class="comment">// 插入正无穷和负无穷，防止迭代器访问到一些奇奇怪怪的内存导致RE</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);s.insert(x);ans=x;</span><br><span class="line">    <span class="comment">// 第一个单独考虑</span></span><br><span class="line">    <span class="keyword">while</span>(--n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        iter it=s.insert(x);</span><br><span class="line">        <span class="comment">// 插入x，并返回x在s中的位置（迭代器）</span></span><br><span class="line">        it--;</span><br><span class="line">        iter l=it;</span><br><span class="line">        it++;it++;</span><br><span class="line">        iter r=it;</span><br><span class="line">        it--;</span><br><span class="line">        <span class="comment">// 迭代器只支持++，--运算符，所以看上去很麻烦。。</span></span><br><span class="line">        <span class="comment">// 其实l就是上一个数，r是下一个数（在s中）</span></span><br><span class="line">        <span class="keyword">if</span>(*l==-inf)ans+=<span class="built_in">abs</span>(x-*r); <span class="comment">// 在最前面</span></span><br><span class="line">        <span class="keyword">if</span>(*r==inf)ans+=<span class="built_in">abs</span>(x-*l);  <span class="comment">// 在最后面</span></span><br><span class="line">        <span class="keyword">if</span>(*l!=-inf&amp;&amp;*r!=inf)ans+=min(<span class="built_in">abs</span>(x-*r),<span class="built_in">abs</span>(x-*l));<span class="comment">// 一般情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据题意我们发现对于每个$A_{i}$，与它绝对值最小的一定是前$i$个数排序后在它前面或后面的数。&lt;/p&gt;
&lt;p&gt;这样的话，我们维护一个单调的序列，插入每天的营业额时计算其波动值即可。&lt;/p&gt;
&lt;p&gt;最暴力的便是插入排序，复杂度$(N^2)$，不能忍受。。&lt;/p&gt;
&lt;p&gt;我们应选择复杂度为$(NlogN)$的方法。&lt;/p&gt;
&lt;p&gt;维护一个单调序列自然想到了 set(平衡树也可以，但是作者懒，想用 STL 水过去，逃……)，因为可能有多个相同的营业额，所以我选择了 multiset。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://sxyugao.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="STL" scheme="https://sxyugao.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>软件推荐</title>
    <link href="https://sxyugao.top/p/c92482f1.html"/>
    <id>https://sxyugao.top/p/c92482f1.html</id>
    <published>2018-05-12T12:19:05.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>用了这么长时间的电脑，在尝试无数次后，终于整理出了一份较为详细的软件清单。我觉得好用的软件，我都会在这里与大家分享，希望大家能够喜欢蛤。 ♪(´▽ ｀)</p><a id="more"></a><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="1、编辑器"><a href="#1、编辑器" class="headerlink" title="1、编辑器"></a>1、编辑器</h4><p>作为一名 Coder，一个好的编辑器自然是必不可少的啦，相信大家也有自己喜欢的编辑器，我要介绍的是 VSCode(Visual Studio Code)。</p><p>笔者原先觉得 VSCode 十分难用，一直使用的是 Atom，后来实在是受不了 Atom 的臃肿和它安装插件的极差体验，来到了 VSCode 的怀抱。嗯，真香。</p><p>不愧是微软爸爸，VSCode 和 Atom 虽然都基于 Electron，但 VSCode 的优化不知道比 Atom 高到哪里去了，内存占用也小得多。再加上 VSCode 的拓展国内安装体验极好，由于众所周知的网络原因，Atom 安装拓展经常失败，更加坚定了我使用 VSCode 的决心。</p><p>优点：<br>1、微软加持，质量有保障。<br>2、资源占用相对较少。<br>3、对国内更为友好的拓展商店。<br>缺点：<br>1、老电脑带不动（雾）<br>2、配置相对较难，对小白不友好。</p><p>官网：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;用了这么长时间的电脑，在尝试无数次后，终于整理出了一份较为详细的软件清单。我觉得好用的软件，我都会在这里与大家分享，希望大家能够喜欢蛤。 ♪(´▽ ｀)&lt;/p&gt;
    
    </summary>
    
      <category term="极客" scheme="https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"/>
    
    
      <category term="软件" scheme="https://sxyugao.top/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1107 - 雷涛的小猫</title>
    <link href="https://sxyugao.top/p/f1f923b5.html"/>
    <id>https://sxyugao.top/p/f1f923b5.html</id>
    <published>2018-05-08T03:00:00.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<p>我们根据题意，发现这是一个 DP 题，定义$f_{i,j}$表示在高度为$i$，当前要爬的树为$j$所能获得的最大柿子数。</p><p>易得状态转移方程：$f_{i,j}=max(f_{i-1,j},f_{i-delta,k}) (1\leq k \leq n)$ 当$i&gt;delta$时后一项成立。</p><p>于是我们得到了一个时间复杂度为$O(H \times N^2)$，空间复杂度为$O(N \times H)$的算法啦。。</p><a id="more"></a><p>然而$N,H=2000$的数据这个时间复杂度还是难以承受，所以需要进一步的优化。</p><p>我们发现对于每个$i$，第二个转移的$i-delta$总是固定的，所以就可以直接处理出高度为$i$时$f_{i,j}$的最大值，时间复杂度降到$O(N \times H)$</p><p>接下来上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc ch=getchar()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> gc;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>;gc)<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>;gc)x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> gc</span></span><br><span class="line"><span class="comment">// 以上为快读，听说不用读入优化会TLE,比如cin、cout</span></span><br><span class="line"><span class="keyword">int</span> n,h,d,g[<span class="number">2005</span>],a[<span class="number">2005</span>][<span class="number">2005</span>],f[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="comment">// g[i]表示高度为i时f[i][j]的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();h=read();d=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i][<span class="number">0</span>]=read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=a[i][<span class="number">0</span>];j++)a[i][read()]++;</span><br><span class="line">        <span class="comment">// 注意，是每个上面有1个，所以要加一，而不是赋值为一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=h;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)f[i][j]=f[i<span class="number">-1</span>][j]+a[j][i];</span><br><span class="line">        <span class="keyword">if</span>(i&gt;d)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)f[i][j]=max(f[i][j],g[i-d]+a[j][i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)g[i]=max(f[i][j],g[i]);</span><br><span class="line">        <span class="comment">// 转移见上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,g[h]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们根据题意，发现这是一个 DP 题，定义$f_{i,j}$表示在高度为$i$，当前要爬的树为$j$所能获得的最大柿子数。&lt;/p&gt;
&lt;p&gt;易得状态转移方程：$f_{i,j}=max(f_{i-1,j},f_{i-delta,k}) (1\leq k \leq n)$ 当$i&amp;gt;delta$时后一项成立。&lt;/p&gt;
&lt;p&gt;于是我们得到了一个时间复杂度为$O(H \times N^2)$，空间复杂度为$O(N \times H)$的算法啦。。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://sxyugao.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="DP" scheme="https://sxyugao.top/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Welcome To YuGao&#39;s House</title>
    <link href="https://sxyugao.top/p/34ad00a8.html"/>
    <id>https://sxyugao.top/p/34ad00a8.html</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2019-05-02T10:06:26.196Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到我的个人主页，Have a good time! ヾ(≧▽≦*)o</p><p>于 2018/4/21，终于借助 Hexo 和 Coding 的页面托管服务将个人主页搭建完毕。</p><p>于 2019/1/28，更新主题并换用 Netlify 托管。</p><p>P.S. 如果有谁想一起建个人主页的，可以通过”关于”联系我一起探讨，顺便交换一下友链蛤</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到我的个人主页，Have a good time! ヾ(≧▽≦*)o&lt;/p&gt;
&lt;p&gt;于 2018/4/21，终于借助 Hexo 和 Coding 的页面托管服务将个人主页搭建完毕。&lt;/p&gt;
&lt;p&gt;于 2019/1/28，更新主题并换用 Netlify 托管。&lt;/p&gt;

      
    
    </summary>
    
      <category term="其他" scheme="https://sxyugao.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://sxyugao.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
