{"meta":{"title":"YuGao's Blog","subtitle":null,"description":"YuGao's Blog","author":"sxyugao","url":"https://sxyugao.top","root":"/"},"pages":[{"title":"","date":"2019-05-02T10:06:26.196Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"baidu_verify_5J7Gx3bmiA.html","permalink":"https://sxyugao.top/baidu_verify_5J7Gx3bmiA.html","excerpt":"","text":"5J7Gx3bmiA"},{"title":"","date":"2019-05-02T10:06:26.196Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"google232d1903d060eb0f.html","permalink":"https://sxyugao.top/google232d1903d060eb0f.html","excerpt":"","text":"google-site-verification: google232d1903d060eb0f.html"},{"title":"About","date":"2018-04-21T13:36:40.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"about/index.html","permalink":"https://sxyugao.top/about/index.html","excerpt":"","text":"一名来自浙江 OIer 蒟蒻，喜欢自己胡乱捣鼓东西，希望你能喜欢蛤 有什么好的建议可以联系我的邮箱或 QQ。 QQ：2645943187 E-mail：sxyugao@qq.com"},{"title":"Friends","date":"2019-05-02T10:06:26.196Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"friends/index.html","permalink":"https://sxyugao.top/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要提供名称、头像和链接哦。 名称： sxyugao头像： https://sxyugao.top/images/avatar.png网址： https://sxyugao.top"}],"posts":[{"title":"Arch Linux 的安装与配置","slug":"ArchLinux的安装与配置","date":"2019-05-11T14:02:52.000Z","updated":"2019-05-11T14:50:41.658Z","comments":true,"path":"p/22002c08.html","link":"","permalink":"https://sxyugao.top/p/22002c08.html","excerpt":"最近折腾了一下 Arch Linux，写一篇安装教程纪念一下。 环境为 HP Notebook x86_64，UEFI。","text":"最近折腾了一下 Arch Linux，写一篇安装教程纪念一下。 环境为 HP Notebook x86_64，UEFI。 前期准备安装介质 前往下载页面，在 China 栏下载镜像 如果你是 Linux 用户推荐使用dd命令写入镜像，Windows 用户可以尝试开源小工具 rufus来制作安装介质。 磁盘空间保证有一个足够大的空闲分区（或新磁盘）。 正式安装启动介质自行设置启动顺序，相信都能解决的。注意，UEFI 启用安全模式启动可能会导致跳过已经写好的介质，如遇到这个问题请设置为传统模式启动。 然后就进入了 U 盘里的 Arch Linux 了。 联网Arch Linux 的安装离不开网络。 如果你使用无线网络，使用以下命令来联网： 1wifi-menu 如果是有线网络： 1dhcpcd 然后使用以下命令检查是否设置成功： 1ping baidu.com 选择镜像源默认读者已经了解 Vim 基本操作。 这里我们选择使用速度最快的清华源（当然你也可以选择其他的）。 通过 Vim 打开 /etc/pacman.d/mirrorlist，在列表最上方写入 https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch，保存并退出。 格式化分区暂时默认已经存在引导分区。 先使用 fdisk -l 查看当前分区情况。 然后将你需要的安装的分区格式化为 ext4 格式： 1mkfs.ext4 /dev/sdxY （请将的sdxY替换为需要的分区） 挂载分区执行以下命令挂载根分区： 1mount /dev/sdaxY /mnt （请将sdxY替换为之前的根分区） 挂载引导分区： 12mkdir /mnt/bootmount /dev/sdxY /mnt/boot （请将sdxY替换为之前的引导分区） 未完持续…","categories":[{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/极客/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://sxyugao.top/tags/Linux/"}]},{"title":"网络流24题","slug":"网络流24题","date":"2019-03-14T03:39:49.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/7a448387.html","link":"","permalink":"https://sxyugao.top/p/7a448387.html","excerpt":"","text":"前言最近发现网络流只会板子不会模型转换，于是来做网络流 24 题。 本文代码以 LibreOJ 上的数据为准，Luogu 的题面可能稍有不同。 本文不定时更新。 （有可能永久咕咕咕）","categories":[{"name":"题解","slug":"题解","permalink":"https://sxyugao.top/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://sxyugao.top/tags/网络流/"}]},{"title":"美化你的PowerShell","slug":"美化你的PowerShell","date":"2019-03-03T02:58:52.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/aa39dfc6.html","link":"","permalink":"https://sxyugao.top/p/aa39dfc6.html","excerpt":"前言作为 Windows 用户，常羡慕 Linux 用户高端大气的终端。 其实，Windows 自带的 PowerShell 也十分的强大。 但是过于简陋的界面不知道劝退了多少用户，于是让我们来美化一下 PowerShell 吧。 以下教程环境均为 PowerShell 5.x。","text":"前言作为 Windows 用户，常羡慕 Linux 用户高端大气的终端。 其实，Windows 自带的 PowerShell 也十分的强大。 但是过于简陋的界面不知道劝退了多少用户，于是让我们来美化一下 PowerShell 吧。 以下教程环境均为 PowerShell 5.x。 准备 PowerShell 5.x Windows10 用户请直接跳过这个步骤，因为 Windows10 内置了 PowerShell 5.x。 我们去官网下载 Windows Management Framework 5.1，选择对应的版本下载。 注意，请关注对应的系统前缀，别下载错了。 下载好以后如果是压缩包运行里面的.msu文件，不要使用.ps1来安装。 安装好以后重启即可。 安装 posh-git折腾 PowerShell 的人大多有 Git 的需求，但是 PowerShell 默认不支持 Git，没有仓库显示和 tab 补全。这时候我们就需要额外的模块来提供这个功能。 执行以下命令安装 posh-git： 1Install-Module posh-git -Scope CurrentUser 它会提示你先安装 NuGet，直接选择“是”。 安装过程中可能会有这样的警告： 1234不受信任的存储库你正在从不受信任的存储库安装模块。如果你信任该存储库，请通过运行 Set-PSRepositorycmdlet 更改其 InstallationPolicy 值。是否确实要从“PSGallery”安装模块?[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 直接选“是”，如果你觉得这个警告烦人，直接执行以下代码信任该仓库即可： 1Set-PSRepository -Name PSGallery -InstallationPolicy Trusted 执行以下命令引入 posh-git： 1Import-Module posh-git 可能会有以下的错误： 12因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。 不要紧，更改一下执行权限： 1Set-ExecutionPolicy -Scope CurrentUser Bypass 再引入 posh-git，然后就能体验到 git 的 tab 补全了。 安装 DirColors 注意，此模块笔者在 Windows7 环境下体验不佳，不推荐非 Windows10 用户使用。 Linux 下的 ls 命令支持对不同文件进行高亮，PowerShell 肯定不能少了这个功能。 我们执行以下命令安装并引入 DirColors： 12Install-Module DirColors -Scope CurrentUserImport-Module DirColors 你还能自定义高亮格式，使用以下代码来引入配置文件： 1Update-DirColors 配置文件的路径 安装 oh-my-posh用过 Linux 的人基本都用过神器 oh-my-zsh，而 PowerShell 也有类似的模块 oh-my-posh。oh-my-posh 提供了一个和 oh-my-zsh 类似的界面，颜值满分。 执行以下命令安装并引入 oh-my-posh： 12Install-Module oh-my-posh -Scope CurrentUserImport-Module oh-my-posh oh-my-posh 的 git 功能依赖 posh-git，请务必先安装 posh-git 使用以下命令来切换 oh-my-posh 的主题： 123Set-Theme robbyrussell# 这个是 oh-my-zsh 的默认主题# 更多主题参见 https://github.com/JanDeDobbeleer/oh-my-posh#Themes 一个漂亮的界面就出现在你面前了。 使用 Cmder笔者在 Windows7 下使用 oh-my-posh 出现了显示问题，怀疑是因为自带的界面过于陈旧，使用 Cmder 就解决了。 去官网下载 Cmder，哪个版本都无所谓。 在解压目录下运行Cmder.exe /REGISTER ALL注册右键菜单，就能在任何目录下使用 Cmder 了。 设置默认启动为 PowerShell，Cmder 的设置就请读者自行搜索，笔者在此不再赘述。 安装 PSReadLine有了漂亮的 shell，为什么不来语法高亮呢？ PSReadLine 正是为 PowerShell 提供命令行高亮的模块。 使用以下命令安装并引入 PSReadLine： 12Install-Module PSReadLine -Scope CurrentUserImport-Module PSReadLine 试着打几句命令，感受一下代码高亮吧。 安装字体可能你在上一步尝试使用其他主题的时候就发现有一些奇怪的字符无法显示，这是因为系统缺失相应的字体。 执行以下代码来安装 Powerline 字体： 123git clone https://github.com/powerline/fonts.gitcd .\\fonts\\.\\install.ps1 安装好后执行以下代码删除多余文件： 12cd ..Remove-Item -Force .\\fonts\\ 打开你的 PowerShell 界面，在标题栏右键选中“默认值”，在“字体”选项中使用著名的“逮虾户”字体 (DejaVu Sans Mono for Powerline)。 当然你也可以根据自己的喜好来安装自己喜欢的字体，比如更纱黑体 (Sarasa Term SC)。更纱黑体内置了 Powerline 字体，字形很纤细，看上去也很舒服。 窗口透明度和配色 这个设置是针对默认命令行窗口的，和前文介绍的 Cmder 无关。笔者在 Windows7 环境下体验不佳，不推荐非 Windows10 用户使用。 Linux 下的终端有着炫酷的配色，全局呼出终端时半透明的窗口也显得逼格满满。 其实，Windows 的终端也能那么炫酷。 打开 PowerShell，在标题栏右键选中“默认值”，在“颜色”选项中设置“不透明度”，透明窗口就设置成功了。 配色方案的话，我们下载微软官方的工具ColorTool来配置。 在解压后在目录下打开 PowerShell，执行.\\colortool -b campbell，即可把终端配色改为campbell。但是如果 ColorTool 自带的配色方案不喜欢怎么办？不要紧，这个小工具支持 itermcolor 格式，我们可以在iTerm2 Color Schemes挑选喜欢的配色主题，下载以后放置在 ColorTool 的 schemes 文件夹下，执行.\\colortool -b 主题名即可。 配置 PROFILE我们的美化基本完成了，让我们理一理现在我们启动 PowerShell 后的操作： 123456Import-Module DirColorsUpdate-DirColors 配置文件的路径 # 若没有可以忽略该行Import-Module oh-my-posh# 由于 oh-my-posh 会自动引入 posh-git，所以我们不必再次引入Set-Theme 你自己喜欢的主题Import-Module PSReadLine 每次都这么打一遍是不是很繁琐？还好 PowerShell 为我们提供了 PROFILE。 在 PowerShell 里键入以下命令： 1$PROFILE 发现输出了一个文件的目录，直接用文本编辑器打开它，输入刚才引入模块的命令，保存并退出。 现在你每次打开 PowerShell 就会先引入 PROFILE 里的命令，节约了大量时间。 如果你自己有其他的需求，自行添加即可。 ScreenfetchLinux 装机以后必晒图之一就是 screenfetch 了，想不到在 Windows 下也有这种东西。 执行以下命令安装 screenfetch： 1Install-Module windows-screenfetch -Scope CurrentUser 令人震惊的是这个模块居然不需要 Import。。 安装好以后直接输入 Screenfetch 就可以看到效果了，十分炫酷。 这是我的辣鸡电脑，分辨率不高，将就看以下吧。。","categories":[{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/极客/"}],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://sxyugao.top/tags/PowerShell/"},{"name":"软件","slug":"软件","permalink":"https://sxyugao.top/tags/软件/"}]},{"title":"洛谷P3613 - 睡觉困难综合征","slug":"洛谷P3613-睡觉困难综合征","date":"2019-02-27T23:46:19.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/6e0912cc.html","link":"","permalink":"https://sxyugao.top/p/6e0912cc.html","excerpt":"首先我们要知道这道题的原型是「NOI2014」起床困难综合症。 总是有出题人喜欢把序列上用线段树解决的题目出到树上，让选手强行写个树链剖分或树分治或某种动态树数据结构。 序列问题转化为树上问题，很容易想到树链剖分，直接上板子。","text":"首先我们要知道这道题的原型是「NOI2014」起床困难综合症。 总是有出题人喜欢把序列上用线段树解决的题目出到树上，让选手强行写个树链剖分或树分治或某种动态树数据结构。 序列问题转化为树上问题，很容易想到树链剖分，直接上板子。 统计答案时因为二进制的特殊性质，后面每一位都选 1 都不大于这一位选 1，所以直接贪心即可。 注意到题面里询问的 x，y 是有方向性的，我们还要维护反向的状态。 但是如果每一位单独维护的话，时间复杂度爆炸，考虑把这些信息压进一个 unsigned long long 里。 这样的话怎么维护信息呢？我们定义一个结构体表示这段进来为 0/1 时出来的情况，不难发现如果这一位出来是 1 只有这么几种情况：左儿子进来是 0，出来是 0，右儿子进来是 0，出来是 1；左儿子进来是 1，出来是 0，右儿子进来是 0，出来是 1；左儿子进来是 0，出来是 1，右儿子进来是 1，出来是 1；左儿子进来是 1，出来是 1，右儿子进来是 1，出来是 1。 用 C++表示就是： 12ans.x0 = (x0 &amp; b.x1) | ((~x0) &amp; b.x0);ans.x1 = (x1 &amp; b.x1) | ((~x1) &amp; b.x0); 可见自然语言的繁琐 代码中用到了一个小技巧——重载运算符，这个能使代码更加简洁易懂，提升代码复用性。 以下就是冗长的代码了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;typedef unsigned long long ull;#define gc c = getchar()ull read() &#123; ull x = 0, f = 1; char gc; for (; !isdigit(c); gc) if (c == '-') f = -1; for (; isdigit(c); gc) x = x * 10 + c - '0'; return x * f;&#125;#undef gcconst int N = 1e5 + 5;int nedge, head[N];struct Edge &#123; int to, nxt;&#125; edge[N &lt;&lt; 1];void add(int x, int y) &#123; edge[++nedge].to = y; edge[nedge].nxt = head[x]; head[x] = nedge;&#125;int n, m, k;int dep[N], fa[N], son[N], siz[N];void dfs1(int x, int f) &#123; fa[x] = f; siz[x] = 1; dep[x] = dep[f] + 1; int mx = 0; for (int i = head[x]; i; i = edge[i].nxt) &#123; int y = edge[i].to; if (y == f) continue; dfs1(y, x); siz[x] += siz[y]; if (siz[y] &gt; mx) &#123; mx = siz[y]; son[x] = y; &#125; &#125;&#125;int tot, id[N], p[N], top[N];void dfs2(int x, int topf) &#123; top[x] = topf; id[x] = ++tot; p[tot] = x; if (!son[x]) return; dfs2(son[x], topf); for (int i = head[x]; i; i = edge[i].nxt) &#123; int y = edge[i].to; if (y == fa[x] || y == son[x]) continue; dfs2(y, y); &#125;&#125;struct Data &#123; ull x0, x1; Data() &#123; x0 = 0, x1 = ~0; &#125; Data(int opt, ull x) &#123; x0 = 0, x1 = ~0; if (opt == 1) &#123; x0 &amp;= x; x1 &amp;= x; &#125; if (opt == 2) &#123; x0 |= x; x1 |= x; &#125; if (opt == 3) &#123; x0 ^= x; x1 ^= x; &#125; &#125; Data operator+(const Data &amp;b) const &#123; Data ans; ans.x0 = (x0 &amp; b.x1) | ((~x0) &amp; b.x0); ans.x1 = (x1 &amp; b.x1) | ((~x1) &amp; b.x0); return ans; &#125; ull query(ull x) &#123; ull ans = 0; for (int i = k - 1; ~i; i--) &#123; if (x0 &amp; (1ull &lt;&lt; i)) &#123; ans += (1ull &lt;&lt; i); &#125; else if (x1 &amp; (1ull &lt;&lt; i) &amp;&amp; (1ull &lt;&lt; i) &lt;= x) &#123; x -= (1ull &lt;&lt; i); ans += (1ull &lt;&lt; i); &#125; &#125; return ans; &#125;&#125;;Data a[N];#define ls (k &lt;&lt; 1)#define rs (k &lt;&lt; 1 | 1)struct Segtree &#123; Data lv[N &lt;&lt; 2], rv[N &lt;&lt; 2]; void pushup(int k) &#123; lv[k] = lv[ls] + lv[rs]; rv[k] = rv[rs] + rv[ls]; &#125; void build(int k, int l, int r) &#123; if (l == r) &#123; lv[k] = rv[k] = a[p[l]]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid + 1, r); pushup(k); &#125; void modify(int k, int l, int r, int p, Data x) &#123; if (l == r) return (void)(lv[k] = rv[k] = x); int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) &#123; modify(ls, l, mid, p, x); &#125; else &#123; modify(rs, mid + 1, r, p, x); &#125; pushup(k); &#125; Data query(int k, int l, int r, int ql, int qr, bool opt) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return opt ? rv[k] : lv[k]; int mid = (l + r) &gt;&gt; 1; if (qr &lt;= mid) return query(ls, l, mid, ql, qr, opt); if (ql &gt; mid) return query(rs, mid + 1, r, ql, qr, opt); Data L = query(ls, l, mid, ql, qr, opt); Data R = query(rs, mid + 1, r, ql, qr, opt); if (opt) return R + L; return L + R; &#125;&#125; seg;#undef ls#undef rsData query(int x, int y) &#123; Data L, R; while (top[x] ^ top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; L = L + seg.query(1, 1, n, id[top[x]], id[x], 1); x = fa[top[x]]; &#125; else &#123; R = seg.query(1, 1, n, id[top[y]], id[y], 0) + R; y = fa[top[y]]; &#125; &#125; Data tmp; if (dep[x] &gt; dep[y]) &#123; tmp = L + seg.query(1, 1, n, id[y], id[x], 1); tmp = tmp + R; return tmp; &#125; if (dep[x] &gt; dep[y]) return L + seg.query(1, 1, n, id[y], id[x], 1) + R; return L + seg.query(1, 1, n, id[x], id[y], 0) + R;&#125;int main() &#123; n = read(), m = read(), k = read(); for (int i = 1; i &lt;= n; i++) &#123; int opt = read(); ull x = read(); a[i] = Data(opt, x); &#125; for (int i = 1; i &lt; n; i++) &#123; int x = read(), y = read(); add(x, y), add(y, x); &#125; dfs1(1, 0), dfs2(1, 1); seg.build(1, 1, n); while (m--) &#123; int opt = read(), x = read(), y = read(); ull z = read(); if (opt == 2) &#123; seg.modify(1, 1, n, id[x], Data(y, z)); &#125; else &#123; Data ans = query(x, y); printf(\"%llu\\n\", ans.query(z)); &#125; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://sxyugao.top/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://sxyugao.top/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://sxyugao.top/tags/树链剖分/"},{"name":"树上问题","slug":"树上问题","permalink":"https://sxyugao.top/tags/树上问题/"}]},{"title":"洛谷P4884 - 多少个1？","slug":"洛谷P4884-多少个1","date":"2018-09-26T23:32:03.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/cbf2e03c.html","link":"","permalink":"https://sxyugao.top/p/cbf2e03c.html","excerpt":"我们通过观察可以发现 $11\\cdots1$ 可以变化为 $\\frac{10^{n}-1}{9}$，于是根据取模的性质，我们可以把原式两边同乘九再加一、原式变为 $10^{n} \\equiv k \\cdot 9 + 1 \\pmod m$，发现这是个 BSGS 的标准式子，由于$m$保证为质数，所以也不必用拓展 BSGS。","text":"我们通过观察可以发现 $11\\cdots1$ 可以变化为 $\\frac{10^{n}-1}{9}$，于是根据取模的性质，我们可以把原式两边同乘九再加一、原式变为 $10^{n} \\equiv k \\cdot 9 + 1 \\pmod m$，发现这是个 BSGS 的标准式子，由于$m$保证为质数，所以也不必用拓展 BSGS。 然后愉快地交了一发，发现只有 80 分。再看一眼数据范围——中间过程相乘会爆$long\\;long$，所以我们需要快速乘来防止溢出。然而丧心病狂的出题人卡 $log_{n}$的快速乘，所以我们需要复杂度更优常数更小的快速乘： 1234567// 传说中复杂度更优的O(1)快速乘// 参考链接：https://zhuanlan.zhihu.com/p/31872064LL mul(LL a, LL b, LL P) &#123; LL L = a * (b &gt;&gt; 25LL) % P * (1LL &lt;&lt; 25) % P; LL R = a * (b &amp; ((1LL &lt;&lt; 25) - 1)) % P; return (L + R) % P;&#125; 看着这么高级其实就是利用了小学生都会的乘法分配律。 我们要计算 $a \\cdot b\\;mod\\;p$，设 $b=L+R$。 那么原式就变为 $a\\cdot(L+R)\\;mod\\;p=((a\\cdot L)\\;mod\\;p+(a\\cdot R)\\;mod\\;p)\\;mod\\;p$。 我们把 $L$ 钦定为 $b$ 的二进制前 $x$ 位，$R$ 为 $b$ 的后 $(64-x)$ 位。 就得到了以上的代码（以上这份代码 $x=25$）。 用上这样的快速乘就可以 AC 了。 以下为代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;typedef long long LL;LL k, m;// C++11标准及以上的哈希表unordered_mapunordered_map&lt;LL, LL&gt; Hash;LL mul(LL a, LL b, LL P) &#123; LL L = a * (b &gt;&gt; 25LL) % P * (1LL &lt;&lt; 25) % P; LL R = a * (b &amp; ((1LL &lt;&lt; 25) - 1)) % P; return (L + R) % P;&#125;LL pw(LL a, LL n, LL P) &#123; LL ans = 1; while (n) &#123; if (n &amp; 1) ans = mul(ans, a, P); a = mul(a, a, P); n &gt;&gt;= 1; &#125; return ans;&#125;LL BSGS(LL a, LL b, LL P) &#123; LL len = ceil(sqrt(P)); for (LL i = 0; i &lt; len; i++) Hash[mul(b, pw(a, i, P), P)] = i; a = pw(a, len, P); for (LL i = 0; i &lt;= len; i++) &#123; LL x = pw(a, i, P); LL j = Hash.count(x) ? Hash[x] : -1; if (j &gt;= 0 &amp;&amp; i * len - j &gt;= 0) return i * len - j; &#125; return -1;&#125;int main() &#123; scanf(\"%lld%lld\", &amp;k, &amp;m); k = k * 9 + 1; k %= m; printf(\"%lld\", BSGS(10, k, m));&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://sxyugao.top/categories/题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://sxyugao.top/tags/数论/"}]},{"title":"CF1037D - Valid BFS?","slug":"CF1037D-Valid-BFS","date":"2018-09-20T01:56:22.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/3396b077.html","link":"","permalink":"https://sxyugao.top/p/3396b077.html","excerpt":"作为一道英文题，我们先解释一下题意： 给你一棵树和它的一个 BFS 序，让你判断这个 BFS 序是否是一个从节点 1 开始的合法 BFS 序。 接下来我们进入正题。 第一眼看到这题时，大部分人都会想到，既然是树，那么它一定是一层一层地向下 BFS。 也就是说，BFS 序中越后出现的节点，它树上的深度肯定是大于它前面的节点的。 于是照这个思想打完后，发现 Wrong Answer 了。","text":"作为一道英文题，我们先解释一下题意： 给你一棵树和它的一个 BFS 序，让你判断这个 BFS 序是否是一个从节点 1 开始的合法 BFS 序。 接下来我们进入正题。 第一眼看到这题时，大部分人都会想到，既然是树，那么它一定是一层一层地向下 BFS。 也就是说，BFS 序中越后出现的节点，它树上的深度肯定是大于它前面的节点的。 于是照这个思想打完后，发现 Wrong Answer 了。 显然这个思路是有反例的，比如下图的情况： 输入给的 BFS 序为：1 5 2 3 4 6 如果根据原来的思路输出就是 Yes，然而正确的 BFS 序显然是 1 5 2 6 3 4 再仔细思考一下，发现合法的 BFS 序不仅要满足刚才的深度条件，而且满足每个节点的父亲在 BFS 序中的位置都要不晚于在它后面出现的节点父亲的位置。 这么看貌似时间复杂度是$O(N^2)$的，如何减小复杂度呢？ 我们发现一个节点的子树是一个连续的区间，我们直接把每个节点重新编号为它父节点的编号，再把连续相同编号的节点的合并成一个节点即可。合并好以后有一个很好的性质，若输入的序列为合法的 BFS 序，重新编号后的序列元素在原序列中的位置单调递增。这样，时间复杂度就降到了$O(n)$了。 以下为代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define gc c = getchar()int read()&#123; int x = 0, f = 1; char gc; for(; !isdigit(c); gc) if(c == '-') f = -1; for(; isdigit(c); gc) x = x * 10 + c - '0'; return x * f;&#125;#undef gcconst int MAXN = 200005;int nedge, head[MAXN];struct Edge &#123; int to, nxt;&#125; edge[MAXN * 2];void add(int x, int y)&#123; edge[++nedge].to = y; edge[nedge].nxt = head[x]; head[x] = nedge;&#125;int d[MAXN], f[MAXN], a[MAXN], b[MAXN], id[MAXN];void dfs(int k, int fa)&#123; d[k] = d[fa] + 1; f[k] = fa; for(int i = head[k]; i; i = edge[i].nxt) &#123; int u = edge[i].to; if(u == fa) continue; dfs(u, k); &#125;&#125;int main()&#123; int n = read(); for(int i = 1; i &lt; n; i++) &#123; int x = read(), y = read(); add(x, y); add(y, x); &#125; dfs(1, 0); for(int i = 1; i &lt;= n; i++) a[i] = read(); for(int i = 1; i &lt;= n; i++) if(d[a[i]] &lt; d[a[i - 1]]) return puts(\"No\"), 0; // 以上为深度条件 for(int i = 1; i &lt;= n; i++) id[a[i]] = i; // 原序列中的位置直接开桶记录 for(int i = 1; i &lt;= n; i++) b[i] = f[a[i]]; // b为重新编号后的序列 int len = unique(b + 1, b + n + 1) - b - 1; for(int i = 1; i &lt;= len; i++) if(id[b[i]] &lt; id[b[i - 1]]) return puts(\"No\"), 0; // 以上为父节点条件 puts(\"Yes\");&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://sxyugao.top/categories/题解/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://sxyugao.top/tags/BFS/"}]},{"title":"洛谷P2094 - 运输","slug":"洛谷P2094-运输","date":"2018-09-20T01:43:27.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/69c58062.html","link":"","permalink":"https://sxyugao.top/p/69c58062.html","excerpt":"这道题第一眼像是合并果子，我们考虑贪心。 我们先选择一种贪心策略：每次选当前最大的两个数合并，直到只剩最后一件物品。 接下来我们证明一下为什么这样是对的： 我们先想一想合并果子，那道题的贪心策略与这道题相反，每次选最小的两个数合并。考虑它为什么是对的——我们发现越先选的数对结果的贡献越大，为了使结果尽可能小，肯定是越小的先选越好。","text":"这道题第一眼像是合并果子，我们考虑贪心。 我们先选择一种贪心策略：每次选当前最大的两个数合并，直到只剩最后一件物品。 接下来我们证明一下为什么这样是对的： 我们先想一想合并果子，那道题的贪心策略与这道题相反，每次选最小的两个数合并。考虑它为什么是对的——我们发现越先选的数对结果的贡献越大，为了使结果尽可能小，肯定是越小的先选越好。 有了这题做基础，我们来考虑这道题。我们发现越先选的数被$k$除的次数也就越多，为了使结果尽可能小，肯定是让越大的数除$k$的次数越多越好，自此，贪心策略证明完毕。 以下为代码： 1234567891011121314151617181920212223#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define gc c = getchar()int read()&#123; int x = 0, f = 1; char gc; for(; !isdigit(c); gc) if(c == '-') f = -1; for(; isdigit(c); gc) x = x * 10 + c - '0'; return x * f;&#125;#undef gcpriority_queue&lt;int&gt;q;int main()&#123; int n = read(), k = read(); for(int i = 1; i &lt;= n; i++) q.push(read()); while(q.size() &gt; 1) &#123; int x = q.top(); q.pop(); int y = q.top(); q.pop(); q.push((x + y) / k); &#125; printf(\"%d\", q.top());&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://sxyugao.top/categories/题解/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://sxyugao.top/tags/STL/"},{"name":"贪心","slug":"贪心","permalink":"https://sxyugao.top/tags/贪心/"}]},{"title":"洛谷P2988 - Test Taking","slug":"洛谷P2988-Test-Taking","date":"2018-06-21T17:10:00.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/1192747.html","link":"","permalink":"https://sxyugao.top/p/1192747.html","excerpt":"作为一道英文题，我们先解释一下题意： 给你一个长度为 $n$ 的 01 串，其中可能至少有 $t_{i}$ 个 1，问最后你给出一个 01 串可能和其匹配的最大长度。 接下来我们进入正题。 第一眼看见觉得是水题，对于每个$t_{i}$枚举应该全 0 还是全 1，但是这显然可以找出反例来。","text":"作为一道英文题，我们先解释一下题意： 给你一个长度为 $n$ 的 01 串，其中可能至少有 $t_{i}$ 个 1，问最后你给出一个 01 串可能和其匹配的最大长度。 接下来我们进入正题。 第一眼看见觉得是水题，对于每个$t_{i}$枚举应该全 0 还是全 1，但是这显然可以找出反例来。 那么我们应该怎么贪心呢？ 首先，我们先提出一个引理： 对于两个长度为 $n$ 的 01 串，$A$ 中 $a$ 个 1，$B$ 中 $b$ 个 1，任一排列中相同位置元素相同的数量至少为 $max(a+b-n,n-a-b)$。 接下来我们证明一下。 1、$a+b&gt;n$，即 $A$ 和 $B$ 匹配 1。 我们为了让相同元素尽可能少，考虑把 $A$ 中的 1 全移到前端，$B$ 中的 1 全移到后端，变成线段覆盖问题，重合部分为 $a+b-n$。 2、$a+b&lt;n$，即 $A$ 和 $B$ 匹配 0. 同理，我们考虑把 $A$ 中的 0 全移到前端，$B$ 中的 0 全移到后端，用同样的方法得出该情况下结果为 $n-a-b$。 3、$a+b=n$，显然答案为 0。 说完了引理，我们再接着讲题。 我们先将 $t$ 从小到大排序，设当前要匹配的 01 串为 $S$，其中有 $x$ 个 1。 对于每对 $t_{i-1},t_{i}$，我们肯定是拿 $S$ 和 $t_{i-1}$ 去匹配 0，和 $t_{i}$ 去匹配 1。 由引理得 $Ans=max(n-t_{i-1}-x,t_{i}+x-n)$。 当 $n-t_{i-1}-x \\geq t_{i}+x-n$ 时， 得 $Ans \\geq (t_{i}-t_{i-1})/2$ 同理当 $n-t_{i-1}-x \\geq t_{i}+x-n$ 时， 得 $Ans \\geq (t_{i}-t_{i-1})/2$ 综上所述，必有 $Ans \\geq (t_{i}-t_{i-1})/2$。 然后特判一下 $t_{1}$ 和 $t_{m}$，全选 0 或全选 1 的情况。 于是我们就可以愉快地切题了。 以下为代码： 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define gc c=getchar()int read() &#123; int x = 0, f = 1; char gc; for (; !isdigit(c); gc)if (c == '-')f = -1; for (; isdigit(c); gc)x = x * 10 + c - '0'; return x * f;&#125;#undef gcint a[10005];int main() &#123; int n = read(), m = read(); for (int i = 1; i &lt;= m; i++)a[i] = read(); sort(a + 1, a + m + 1); int ans = max(a[1], n - a[m]); for (int i = 1; i &lt;= m; i++)ans = max(ans, (a[i + 1] - a[i]) / 2); printf(\"%d\", ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://sxyugao.top/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://sxyugao.top/tags/贪心/"},{"name":"排序","slug":"排序","permalink":"https://sxyugao.top/tags/排序/"}]},{"title":"洛谷P1351 - 联合权值","slug":"洛谷P1351-联合权值","date":"2018-06-18T18:05:00.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/b30e912f.html","link":"","permalink":"https://sxyugao.top/p/b30e912f.html","excerpt":"由题意得一个点对的联合权值是它们的点权相乘，而 2 个点形成点对的条件是距离为 2。 于是我们可以通过枚举这 2 个节点的公共点来算出以这个点为中心的权值和。 但是先枚举中心点再枚举其相邻的节点时间复杂度达到了$O(n^3)$，我们不能承受。 经过观察发现，对于特定的点，它都要乘上除自己以外的所有点权，再相加。然后我们就可以先处理出点权和，统计答案的时候把自己减去即可。","text":"由题意得一个点对的联合权值是它们的点权相乘，而 2 个点形成点对的条件是距离为 2。 于是我们可以通过枚举这 2 个节点的公共点来算出以这个点为中心的权值和。 但是先枚举中心点再枚举其相邻的节点时间复杂度达到了$O(n^3)$，我们不能承受。 经过观察发现，对于特定的点，它都要乘上除自己以外的所有点权，再相加。然后我们就可以先处理出点权和，统计答案的时候把自己减去即可。 虽然说题面里说是有序点对，但我们每次枚举的时候都定方向为当前点-&gt;其他点，所以最后也不需要再乘 2 了。 枚举每个点，再枚举相邻的每条边，复杂度看似是$O(n^2)$，但由于树的度数为$n-1$，实际复杂度应为$O(n+m)$ 当然，这道题还有一个小小的坑点，题面里只说联合权值之和要取余，最大值却不需要取余，这个细节注意一下。 接下来上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define gc c = getchar()int read() &#123; int x = 0, f = 1; char gc; for (; !isdigit(c); gc) if (c == '-') f = -1; for (; isdigit(c); gc) x = x * 10 + c - '0'; return x * f;&#125;#undef gcconst int MAXN = 200005;const int P = 10007;int n, Ans, ans, a[MAXN];int nedge, head[MAXN];struct Edge &#123; int to, nxt;&#125; edge[MAXN * 2]; // 边表2倍勿忘void add(int x, int y) &#123; edge[++nedge].to = y; edge[nedge].nxt = head[x]; head[x] = nedge;&#125;void calc(int k) &#123; // 关键函数 int Max = 0, Maxx = 0, sum = 0; // Max为与k相连最大的点权值，Maxx为次大值 for (int i = head[k]; i; i = edge[i].nxt) &#123; int u = edge[i].to; if (a[u] &gt; Max) &#123; Maxx = Max; Max = a[u]; &#125; else if (a[u] &gt; Maxx) Maxx = a[u]; // 更新最大、次大值 sum = (sum + a[u]) % P; // 累加权值和 &#125; for (int i = head[k]; i; i = edge[i].nxt) &#123; int u = edge[i].to; ans = (ans + (sum - a[u]) * a[u]) % P; // 当前点对答案的贡献为（除自己外总和）*（自己的权值） &#125; Ans = max(Ans, Max * Maxx); // 当前公共点所能产生的最大联合权值为（最大值）*（次大值）&#125;int main() &#123; int n = read(); for (int i = 1; i &lt; n; i++) &#123; int x = read(), y = read(); add(x, y), add(y, x); &#125; // 前向星建边 for (int i = 1; i &lt;= n; i++) a[i] = read(); // 读入点权 for (int i = 1; i &lt;= n; i++) calc(i); // 枚举每个公共点计算 printf(\"%d %d\", Ans, (ans + P) % P); // 因为我们在统计的时候是减一个数，所以可能会出现ans小于0的情况，要(ans+P)%P&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://sxyugao.top/categories/题解/"}],"tags":[{"name":"枚举","slug":"枚举","permalink":"https://sxyugao.top/tags/枚举/"},{"name":"图论","slug":"图论","permalink":"https://sxyugao.top/tags/图论/"}]},{"title":"洛谷P1432 - 倒水问题","slug":"洛谷P1432-倒水问题","date":"2018-06-11T12:32:42.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/a5166969.html","link":"","permalink":"https://sxyugao.top/p/a5166969.html","excerpt":"很容易看出这是宽度优先搜索，因为要求步数最少，且每个操作代价相同。 我们可以按操作类别分 6 种情况扩展，如果搜到最终状态就跳出 BFS（搜索顺序可以随意，因为 spj 已经配置好了，不像数据修改前要有特定的顺序）。 记得标记已经出现过的情况，不然会 TLE/MLE；","text":"很容易看出这是宽度优先搜索，因为要求步数最少，且每个操作代价相同。 我们可以按操作类别分 6 种情况扩展，如果搜到最终状态就跳出 BFS（搜索顺序可以随意，因为 spj 已经配置好了，不像数据修改前要有特定的顺序）。 记得标记已经出现过的情况，不然会 TLE/MLE； 做宽搜题，队列能开多大就开多大。 正确开队列的方法：我们发现$C_{a}，C_{b}$最大只有$10^3$，也就是说总状态数最多只有$10^6$，所以把队列大小开成比状态数稍微多一点就行了。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;bool vis[2005][2005];int va, vb, vc;void init() &#123; memset(vis, 0, sizeof(vis)); scanf(\"%d%d%d\", &amp;va, &amp;vb, &amp;vc);&#125;struct Data &#123; int a, b, nxt, k, step;&#125; q[5000005];void print(int p) &#123; int t = q[p].nxt; if (!t) return; print(t); printf(\"%d \", q[p].k);&#125;bool nxt(int l, int &amp;r, int a, int b, int opt) &#123; // 获取下一个状态 if (vis[a][b]) return 0; // 剪枝 r++; q[r].a = a, q[r].b = b, q[r].k = opt; q[r].nxt = l; vis[a][b] = 1; q[r].step = q[l].step + 1; if (q[r].b == vc) &#123; printf(\"%d \", q[r].step); print(r), puts(\"\"); &#125; return q[r].b == vc;&#125;void solve() &#123; q[1].a = q[1].b = q[1].k = q[1].nxt = q[1].step = 0; vis[0][0] = 1; // 初始状态 int l = 0, r = 1; bool f = 0; while (l &lt; r &amp;&amp; !f) &#123; l++; f |= nxt(l, r, va, q[l].b, 1); // 把A装满 f |= nxt(l, r, q[l].a, vb, 2); // 把B装满 f |= nxt(l, r, 0, q[l].b, 3); // 把A倒空 f |= nxt(l, r, q[l].a, 0, 4); // 把B倒空 int ta = q[l].a + q[l].b, tb = 0; if (ta &gt; va) &#123; tb = ta - va; ta = va; &#125; // 如果超出容量了，那么处理一下 f |= nxt(l, r, ta, tb, 5); // 把B倒给A ta = 0, tb = q[l].a + q[l].b; if (tb &gt; vb) &#123; ta = tb - vb; tb = vb; &#125; f |= nxt(l, r, ta, tb, 6); // 把A倒给B &#125;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; init(); solve(); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://sxyugao.top/categories/题解/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://sxyugao.top/tags/BFS/"},{"name":"STL","slug":"STL","permalink":"https://sxyugao.top/tags/STL/"}]},{"title":"洛谷P2234 - 「HNOI2002」营业额统计","slug":"洛谷P2234-营业额统计","date":"2018-06-08T02:35:00.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/b5fb6ff8.html","link":"","permalink":"https://sxyugao.top/p/b5fb6ff8.html","excerpt":"根据题意我们发现对于每个$A_{i}$，与它绝对值最小的一定是前$i$个数排序后在它前面或后面的数。 这样的话，我们维护一个单调的序列，插入每天的营业额时计算其波动值即可。 最暴力的便是插入排序，复杂度$(N^2)$，不能忍受。。 我们应选择复杂度为$(NlogN)$的方法。 维护一个单调序列自然想到了 set(平衡树也可以，但是作者懒，想用 STL 水过去，逃……)，因为可能有多个相同的营业额，所以我选择了 multiset。","text":"根据题意我们发现对于每个$A_{i}$，与它绝对值最小的一定是前$i$个数排序后在它前面或后面的数。 这样的话，我们维护一个单调的序列，插入每天的营业额时计算其波动值即可。 最暴力的便是插入排序，复杂度$(N^2)$，不能忍受。。 我们应选择复杂度为$(NlogN)$的方法。 维护一个单调序列自然想到了 set(平衡树也可以，但是作者懒，想用 STL 水过去，逃……)，因为可能有多个相同的营业额，所以我选择了 multiset。 下次有空写一个 set 的教程。 以下为代码： 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;set&gt;using namespace std;typedef multiset&lt;int&gt;::iterator iter;// 定义iter类型，免去每次打一大串的苦恼const int inf=0x7fffffff;int n,x,ans;multiset&lt;int&gt;s;inline int min(int a,int b)&#123;return a&lt;b?a:b;&#125;inline int abs(int x)&#123;return x&lt;0?-x:x;&#125;int main()&#123; s.insert(inf);s.insert(-inf); // 插入正无穷和负无穷，防止迭代器访问到一些奇奇怪怪的内存导致RE scanf(\"%d\",&amp;n); scanf(\"%d\",&amp;x);s.insert(x);ans=x; // 第一个单独考虑 while(--n)&#123; scanf(\"%d\",&amp;x); iter it=s.insert(x); // 插入x，并返回x在s中的位置（迭代器） it--; iter l=it; it++;it++; iter r=it; it--; // 迭代器只支持++，--运算符，所以看上去很麻烦。。 // 其实l就是上一个数，r是下一个数（在s中） if(*l==-inf)ans+=abs(x-*r); // 在最前面 if(*r==inf)ans+=abs(x-*l); // 在最后面 if(*l!=-inf&amp;&amp;*r!=inf)ans+=min(abs(x-*r),abs(x-*l));// 一般情况 &#125; printf(\"%d\",ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://sxyugao.top/categories/题解/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://sxyugao.top/tags/STL/"}]},{"title":"软件推荐","slug":"软件推荐","date":"2018-05-12T12:19:05.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/c92482f1.html","link":"","permalink":"https://sxyugao.top/p/c92482f1.html","excerpt":"前言用了这么长时间的电脑，在尝试无数次后，终于整理出了一份较为详细的软件清单。我觉得好用的软件，我都会在这里与大家分享，希望大家能够喜欢蛤。 ♪(´▽ ｀)","text":"前言用了这么长时间的电脑，在尝试无数次后，终于整理出了一份较为详细的软件清单。我觉得好用的软件，我都会在这里与大家分享，希望大家能够喜欢蛤。 ♪(´▽ ｀) 列表1、编辑器作为一名 Coder，一个好的编辑器自然是必不可少的啦，相信大家也有自己喜欢的编辑器，我要介绍的是 VSCode(Visual Studio Code)。 笔者原先觉得 VSCode 十分难用，一直使用的是 Atom，后来实在是受不了 Atom 的臃肿和它安装插件的极差体验，来到了 VSCode 的怀抱。嗯，真香。 不愧是微软爸爸，VSCode 和 Atom 虽然都基于 Electron，但 VSCode 的优化不知道比 Atom 高到哪里去了，内存占用也小得多。再加上 VSCode 的拓展国内安装体验极好，由于众所周知的网络原因，Atom 安装拓展经常失败，更加坚定了我使用 VSCode 的决心。 优点：1、微软加持，质量有保障。2、资源占用相对较少。3、对国内更为友好的拓展商店。缺点：1、老电脑带不动（雾）2、配置相对较难，对小白不友好。 官网：https://code.visualstudio.com/","categories":[{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/极客/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://sxyugao.top/tags/软件/"}]},{"title":"洛谷P1107 - 雷涛的小猫","slug":"洛谷P1107-雷涛的小猫","date":"2018-05-08T03:00:00.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/f1f923b5.html","link":"","permalink":"https://sxyugao.top/p/f1f923b5.html","excerpt":"我们根据题意，发现这是一个 DP 题，定义$f_{i,j}$表示在高度为$i$，当前要爬的树为$j$所能获得的最大柿子数。 易得状态转移方程：$f_{i,j}=max(f_{i-1,j},f_{i-delta,k}) (1\\leq k \\leq n)$ 当$i&gt;delta$时后一项成立。 于是我们得到了一个时间复杂度为$O(H \\times N^2)$，空间复杂度为$O(N \\times H)$的算法啦。。","text":"我们根据题意，发现这是一个 DP 题，定义$f_{i,j}$表示在高度为$i$，当前要爬的树为$j$所能获得的最大柿子数。 易得状态转移方程：$f_{i,j}=max(f_{i-1,j},f_{i-delta,k}) (1\\leq k \\leq n)$ 当$i&gt;delta$时后一项成立。 于是我们得到了一个时间复杂度为$O(H \\times N^2)$，空间复杂度为$O(N \\times H)$的算法啦。。 然而$N,H=2000$的数据这个时间复杂度还是难以承受，所以需要进一步的优化。 我们发现对于每个$i$，第二个转移的$i-delta$总是固定的，所以就可以直接处理出高度为$i$时$f_{i,j}$的最大值，时间复杂度降到$O(N \\times H)$ 接下来上代码： 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;#define gc ch=getchar()inline int read()&#123; int x=0,f=1;char gc; for(;ch&lt;'0'||ch&gt;'9';gc)if(ch=='-')f=-1; for(;ch&gt;='0'&amp;&amp;ch&lt;='9';gc)x=x*10+ch-'0'; return x*f;&#125;#undef gc// 以上为快读，听说不用读入优化会TLE,比如cin、coutint n,h,d,g[2005],a[2005][2005],f[2005][2005];// g[i]表示高度为i时f[i][j]的最大值int main()&#123; n=read();h=read();d=read(); for(int i=1;i&lt;=n;i++)&#123; a[i][0]=read(); for(int j=1;j&lt;=a[i][0];j++)a[i][read()]++; // 注意，是每个上面有1个，所以要加一，而不是赋值为一 &#125; for(int i=1;i&lt;=h;i++)&#123; for(int j=1;j&lt;=n;j++)f[i][j]=f[i-1][j]+a[j][i]; if(i&gt;d)for(int j=1;j&lt;=n;j++)f[i][j]=max(f[i][j],g[i-d]+a[j][i]); for(int j=1;j&lt;=n;j++)g[i]=max(f[i][j],g[i]); // 转移见上 &#125; printf(\"%d\",g[h]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://sxyugao.top/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://sxyugao.top/tags/DP/"}]},{"title":"Welcome To YuGao's House","slug":"Welcome","date":"2018-04-20T16:00:00.000Z","updated":"2019-05-02T10:06:26.196Z","comments":true,"path":"p/34ad00a8.html","link":"","permalink":"https://sxyugao.top/p/34ad00a8.html","excerpt":"","text":"欢迎来到我的个人主页，Have a good time! ヾ(≧▽≦*)o 于 2018/4/21，终于借助 Hexo 和 Coding 的页面托管服务将个人主页搭建完毕。 于 2019/1/28，更新主题并换用 Netlify 托管。 P.S. 如果有谁想一起建个人主页的，可以通过”关于”联系我一起探讨，顺便交换一下友链蛤","categories":[{"name":"其他","slug":"其他","permalink":"https://sxyugao.top/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://sxyugao.top/tags/其他/"}]}]}